
{% load static %}


  <div id="footer_placeholder" class="footer" hx-get="{% url 'core:footer' %}" hx-trigger="load"
    hx-target="#footer_placeholder" hx-swap="innerHTML"></div>



  <!-- Global Bootstrap Modal (single instance, static in DOM) -->
  <div class="modal fade" id="modal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <!-- htmx will swap content here -->
      </div>
    </div>
  </div>

  {% block htmxmodal %}
  <!-- Only load modal content via htmx, not the modal container -->
  <div hx-get="{% url 'core:modal' %}" hx-trigger="click" hx-target="#modal .modal-content" hx-swap="innerHTML">
  </div>
  {% endblock %}





  <script type="text/javascript" src="{% static 'js/jquery.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/all.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/aos.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/loader_images.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/htmx_helper.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/scripts.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/html_debugging.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/footer_expand.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/htmx_clear_main.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/sbpro_scripts.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/toasts.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/toast_htmx.js' %}"></script>

  <script type="text/javascript" src="{% static 'js/debugging.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/open_close_drawersidemenu.js' %}"></script>
  <script type="text/javascript" src="{% static 'js/base_system.js' %}"></script>

  <script type="text/javascript">

    (function () {


      // ---- config ----
      var SHOW_DELAY = 120;   // don't flash on super-fast requests
      var MIN_VISIBLE = 200;  // keep loader up for at least this long (ms)
      var FADE_MS = 400;  // match your CSS transition

      // ---- state ----
      var pending = 0;
      var showTimer = null;
      var visibleSince = 0;

      var holds = 0;
      function hold()   { holds++; }
      function release(){
        if (holds > 0) holds--;
        // if no holds and no pending requests, allow hide now
        if (holds === 0 && pending === 0) {
          var elapsed = now() - visibleSince;
          var wait = Math.max(0, MIN_VISIBLE - elapsed);
          setTimeout(hideLoader, wait);
        }
      }

      window.hxLoader = { hold: hold, release: release };

      function now() { return (window.performance && performance.now) ? performance.now() : Date.now(); }

      function getLoader() { return document.getElementById('global-loader'); }

      function reallyShow() {
        var loader = getLoader();
        if (!loader) return;
        loader.style.display = 'flex';
        // force reflow so CSS transitions apply
        void loader.offsetWidth;
        loader.classList.remove('fade-out');
        loader.classList.add('fade-in');
        visibleSince = now();
      }

      function requestStarted() {
        pending++;
        if (pending === 1) {
          clearTimeout(showTimer);
          showTimer = setTimeout(reallyShow, SHOW_DELAY);
        }
      }

      function hideLoader() {
        var loader = getLoader();
        if (!loader) return;
        loader.classList.remove('fade-in');
        loader.classList.add('fade-out');
        setTimeout(function () {
          // only hide if nothing else started since we scheduled this
          if (pending === 0) {
            loader.style.display = 'none';
            loader.classList.remove('fade-out');
          }
        }, FADE_MS);
      }

      function requestFinished() {
        if (pending > 0) pending--;
        if (pending === 0) {
          clearTimeout(showTimer);
          var elapsed = now() - visibleSince;
          var wait = Math.max(0, MIN_VISIBLE - elapsed);
          setTimeout(hideLoader, wait);
        }
      }

      // ---- HTMX hooks ----

      // One place for CSRF header + "request started"
      document.body.addEventListener('htmx:configRequest', function (e) {
        // CSRF header
        var token =
          document.querySelector('input[name=csrfmiddlewaretoken]')?.value ||
          document.querySelector('meta[name="csrf-token"]')?.content;
        if (token) e.detail.headers['X-CSRFToken'] = token;

        requestStarted();
      });

      // Fires after every request completes (success or error), even if nothing was swapped
      document.body.addEventListener('htmx:afterRequest', function () {
        requestFinished();
      });
    })();

  </script>


  {% block extra_js %}{% endblock %}

<script>
document.body.addEventListener('htmx:afterSwap', function (e) {
  // animate only when we swapped the account tab area
  if (!e.detail.target || !e.detail.target.matches('.tabloader')) return;
  var child = e.detail.target.firstElementChild;   // root of the new partial
  if (!child) return;
  child.classList.add('tab-fly-in');
  // remove class after the animation so it can re-trigger next time
  setTimeout(function(){ child.classList.remove('tab-fly-in'); }, 300);
});
</script>


  {% comment %} this is for development only. remove below script when deploying to production {% endcomment %}

  <script>
    (function () {
      // ---- toggle ----
      const KEY = 'hxlog';
      const isOn = () => localStorage.getItem(KEY) === '1';
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'l') {
          localStorage.setItem(KEY, isOn() ? '0' : '1');
          console.info('HTMX debug %s', isOn() ? 'ON' : 'OFF');
        }
      });

      // ---- boot logger ----
      function boot() {
        if (!window.htmx) { console.warn('[hxlog] htmx not found'); return; }
        if (!isOn()) return;

        // Basic built-in logger (prints event names)
        try { htmx.logAll(); } catch (_) { }

        // Rich logger
        const events = [
          // request lifecycle
          'htmx:configRequest', 'htmx:beforeRequest', 'htmx:send',
          'htmx:beforeSwap', 'htmx:afterSwap', 'htmx:afterRequest', 'htmx:responseError',
          // load lifecycle
          'htmx:beforeOnLoad', 'htmx:afterOnLoad', 'htmx:load',
          // misc
          'htmx:historyRestore', 'htmx:historyCacheMiss',
          'htmx:beforeCleanupElement', 'htmx:confirm',
          'htmx:validation:validate', 'htmx:validation:failed'
        ];

        const t0 = new WeakMap(); // xhr -> start time
        const color = (n) => /error/i.test(n) ? 'color:#e53935' : 'color:#03a9f4';
        const now = () => (performance && performance.now) ? performance.now() : Date.now();

        // give each request a client ID so you can correlate logs (optional)
        document.body.addEventListener('htmx:configRequest', (e) => {
          // Add CSRF here too if you want—already in your app’s handler
          const id = 'hx-' + Math.random().toString(36).slice(2, 8) + '-' + Date.now().toString(36);
          (e.detail.requestConfig.headers ||= {})['X-Request-ID'] = id;
          e.detail.__hxReqId = id;
        });

        // Start timer when xhr exists
        document.body.addEventListener('htmx:beforeRequest', (e) => {
          if (e.detail?.xhr) t0.set(e.detail.xhr, now());
        });

        // Log everything nicely
        events.forEach((name) => {
          document.body.addEventListener(name, (e) => {
            if (!isOn()) return;

            const d = e.detail || {};
            const cfg = d.requestConfig || {};
            const verb = (cfg.verb || 'GET').toUpperCase();
            const path = cfg.path || '(unknown)';
            const started = d.xhr && t0.has(d.xhr) ? t0.get(d.xhr) : null;
            const dur = started != null ? (now() - started) : null;

            console.groupCollapsed(
              `%c${name}%c ${verb} ${path}${dur != null ? `  +${Math.round(dur)}ms` : ''}`,
              `${color(name)};font-weight:bold`, 'color:#999'
            );
            try {
              console.log('event:', name);
              console.log('trigger elt:', d.elt || e.target);
              console.log('target:', d.target);
              if (d.parameters) { console.log('parameters:'); console.table(d.parameters); }
              if (cfg.headers) { console.log('request headers:'); console.table(cfg.headers); }
              if (d.pathInfo) console.log('pathInfo:', d.pathInfo);
              if (d.errors) console.log('validation errors:', d.errors);

              if (d.xhr) {
                const hdrs = {};
                ['HX-Trigger', 'HX-Redirect', 'HX-Push-Url', 'HX-Replace-Url', 'Content-Type', 'X-Request-ID']
                  .forEach(h => { const v = d.xhr.getResponseHeader?.(h); if (v) hdrs[h] = v; });
                console.log('status:', d.xhr.status);
                if (Object.keys(hdrs).length) console.log('response headers:', hdrs);

                // small response preview
                const body = d.xhr.responseText || '';
                if (body.length) {
                  const sample = body.length > 600 ? body.slice(0, 600) + ' …(+)' : body;
                  console.log('response sample:', sample);
                }
              }
            } finally { console.groupEnd(); }
          });
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', boot);
      } else {
        boot();
      }
    })();
  </script>
  <script>
    (function () {
      // ---------- config ----------
      var SHOW_DELAY = 120;   // don't flash loader on very fast calls
      var MIN_VISIBLE = 200;   // keep it visible briefly once shown
      var FADE_MS = 400;   // match your CSS transition

      // disable global loader for specific requests:
      // e.g. <button data-no-global-loader hx-get="/ping">Ping</button>
      var NO_LOADER_SELECTOR = '[data-no-global-loader]';

      // Treat these HTTP codes specially
      var AUTH_CODES = new Set([401]);  // unauth -> show login partial in place
      var CSRF_CODES = new Set([403, 419]); // CSRF/session issues (framework-dependent)
      var RETRY_GET_ON = new Set([502, 503, 504]); // optional auto-retry for GETs

      // ---------- state ----------
      var pending = 0;
      var showTimer = null;
      var visibleSince = 0;
      var t0 = new WeakMap();        // xhr -> start time
      var skipForElt = new WeakMap();// elt -> boolean (skip loader)
      var retrying = new WeakSet();  // xhrs we've retried already (avoid loops)

      function now() { return (performance && performance.now) ? performance.now() : Date.now(); }
      function loaderEl() { return document.getElementById('global-loader'); }

      function reallyShow() {
        var el = loaderEl(); if (!el) return;
        el.style.display = 'flex';
        void el.offsetWidth; // reflow so transition applies
        el.classList.remove('fade-out');
        el.classList.add('fade-in');
        visibleSince = now();
      }

      function requestStarted(elt) {
        // skip loader for marked elements
        var skip = !!(elt && elt.closest(NO_LOADER_SELECTOR));
        if (elt) skipForElt.set(elt, skip);

        if (!skip) {
          pending++;
          if (pending === 1) {
            clearTimeout(showTimer);
            showTimer = setTimeout(reallyShow, SHOW_DELAY);
          }
        }
      }

      function hideLoader() {
        var el = loaderEl(); if (!el) return;
        el.classList.remove('fade-in');
        el.classList.add('fade-out');
        setTimeout(function () {
          if (pending === 0) {
            el.style.display = 'none';
            el.classList.remove('fade-out');
          }
        }, FADE_MS);
      }

      function requestFinished(elt) {
        var skip = !!(elt && skipForElt.get(elt));
        if (!skip && pending > 0) pending--;
        if (pending === 0) {
          clearTimeout(showTimer);
          var elapsed = now() - visibleSince;
          var wait = Math.max(0, MIN_VISIBLE - elapsed);
          setTimeout(hideLoader, wait);
        }
      }

      // ---------- helpers ----------
      function getHeader(xhr, name) {
        try { return xhr.getResponseHeader && xhr.getResponseHeader(name); } catch (_) { return null; }
      }

      // Optional: idempotent GET auto-retry with small backoff when server is busy
      function maybeRetryGET(e) {
        var xhr = e.detail.xhr;
        var cfg = e.detail.requestConfig || {};
        var elt = cfg.elt;
        var verb = (cfg.verb || 'GET').toUpperCase();

        if (verb !== 'GET') return false;
        if (!RETRY_GET_ON.has(xhr.status)) return false;
        if (retrying.has(xhr)) return false; // Already retried once

        retrying.add(xhr);
        // simple backoff 200–500ms
        var backoff = 200 + Math.floor(Math.random() * 300);
        setTimeout(function () {
          // re-issue the same request config via htmx.ajax
          // use the same path/headers/target/swap
          try {
            htmx.ajax(verb, cfg.path, {
              target: e.detail.target,
              swap: cfg.swapStyle || 'innerHTML',
              headers: cfg.headers || {}
            });
          } catch (_) { /* swallow */ }
        }, backoff);
        return true;
      }

      // ---------- HTMX hooks ----------
      // Add CSRF + mark start
      document.body.addEventListener('htmx:configRequest', function (e) {
        try {
          var token =
            document.querySelector('input[name=csrfmiddlewaretoken]')?.value ||
            document.querySelector('meta[name="csrf-token"]')?.content;
          if (token) e.detail.headers['X-CSRFToken'] = token;
        } catch (_) { /* ignore */ }

        // Correlate requests if you want server pairing
        try {
          // Only set if not already present (client logger may have set it)
          if (!e.detail.requestConfig.headers?.['X-Request-ID']) {
            var rid = 'hx-' + Math.random().toString(36).slice(2, 8) + '-' + Date.now().toString(36);
            (e.detail.requestConfig.headers ||= {})['X-Request-ID'] = rid;
          }
        } catch (_) { }

        requestStarted(e.detail.elt);
      });

      // Timer start (works even if no swap occurs)
      document.body.addEventListener('htmx:beforeRequest', function (e) {
        if (e.detail?.xhr) t0.set(e.detail.xhr, now());
      });

      // Handle aborts/timeouts explicitly (keep counter accurate)
      document.body.addEventListener('htmx:abort', function (e) {
        requestFinished(e.detail.elt);
      });
      document.body.addEventListener('htmx:timeout', function (e) {
        requestFinished(e.detail.elt);
      });

      // Always runs at the end (success or error, swap or not)
      document.body.addEventListener('htmx:afterRequest', function (e) {
        try {
          var xhr = e.detail.xhr;
          var cfg = e.detail.requestConfig || {};
          var elt = cfg.elt;
          var status = xhr.status || 0;

          // Auto-retry idempotent GETs on transient server errors
          if (maybeRetryGET(e)) return; // don't finish yet; retry will manage loader

          // Auth/CSRF handling: if your server returns 401 with login partial,
          // HTMX will have swapped it in place already. You can also sniff and
          // take extra actions here if desired.
          if (AUTH_CODES.has(status)) {
            // Example: focus first field in the injected login form
            var f = document.querySelector('.login form input, form [name=username]');
            if (f) try { f.focus(); } catch (_) { }
          }
          if (CSRF_CODES.has(status)) {
            console.warn('CSRF/session issue detected; status=', status);
            // optional: toast or force a fresh login panel via HX trigger
          }

          // Observe HX-Redirect without changing URL yourself (htmx will handle it)
          var hxredir = getHeader(xhr, 'HX-Redirect');
          if (hxredir) {
            // If you want to keep the URL bar unchanged, you should generally avoid
            // sending HX-Redirect from the server for HTMX flows. Your middleware
            // already converts auth redirects to HX-Redirect (to /login/).
            // Nothing to do here; just let htmx act.
          }

          // Duration / metrics (optional)
          var start = t0.get(xhr);
          if (start != null) {
            var ms = Math.round(now() - start);
            // console.debug('HTMX request finished in', ms, 'ms', cfg.path);
          }
        } finally {
          // Always finish bookkeeping
          requestFinished(e.detail.requestConfig?.elt);
        }
      });

      // Safety nets: if something restores history or swaps a big container,
      // ensure loader cannot get stuck
      document.body.addEventListener('htmx:historyRestore', function () {
        if (pending === 0) hideLoader();
      });
    })();
  </script>

  <!-- Toast container (Bootstrap 5) -->
  <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
    <div id="globalToast" class="toast align-items-center text-white bg-primary border-0" role="alert"
      aria-live="assertive" aria-atomic="true" data-bs-delay="4000">
      <div class="d-flex">
        <div class="toast-body" id="globalToastBody">
          <!-- Toast message will appear here -->
        </div>
        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"
          aria-label="Close"></button>
      </div>
    </div>
  </div>





</body>

</html>